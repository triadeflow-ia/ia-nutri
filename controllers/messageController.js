import { normalizePhoneNumber } from '../utils/phoneUtils.js';
import { formatMessageWithDate, getTimeBasedGreeting } from '../utils/messageFormatter.js';
import { getCurrentDate } from '../utils/dateUtils.js';
import * as redisService from '../services/redisService.js';
import * as openaiService from '../services/openaiService.js';
import * as whatsappService from '../services/whatsappService.js';
import * as mediaService from '../services/mediaService.js';
import * as audioService from '../services/audioService.js';
import { config } from '../config/index.js';
import moment from 'moment-timezone';

// Map para armazenar mensagens temporariamente
const messageBuffers = new Map();
const bufferTimeouts = new Map();

export const processMessage = async (message, profileName, phoneNumberId, res) => {
  try {
    const phoneNumber = normalizePhoneNumber(message.from);
    console.log("Normalized phone number:", phoneNumber);

    // Verificar se √© mensagem duplicada
    const existingMessageData = await redisService.getMessageData(message.id);
    
    if (existingMessageData && existingMessageData.timestamp === String(message.timestamp)) {
      console.log("Mensagem duplicada ignorada.");
      if (!res.headersSent) {
        res.sendStatus(200);
      }
      return;
    }

    // Obter ou criar threadId
    let threadId = await redisService.getThreadId(phoneNumber);

    if (!threadId) {
      threadId = await createNewThread(phoneNumber, message, profileName);
    }

    // Salvar mensagem no Redis
    await saveMessageToRedis(message, phoneNumber, threadId, profileName);

    // Processar diferentes tipos de mensagem
    if (message.text) {
      await handleTextMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId);
    } else if (message.audio) {
      await handleAudioMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId);
    } else if (message.image) {
      await handleImageMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId);
    } else if (message.document && message.document.mime_type === "application/pdf") {
      await handlePdfMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId);
    } else {
      // Tipo de mensagem n√£o suportado
      console.log(`Tipo de mensagem n√£o suportado: ${message.type}`);
      if (!res.headersSent) {
        res.sendStatus(200);
      }
    }
  } catch (error) {
    console.error("Error processing message:", error);
    throw error;
  }
};

async function createNewThread(phoneNumber, message, profileName) {
  console.log(`Nenhum threadId encontrado para o n√∫mero ${phoneNumber}, criando um novo thread...`);
  const greeting = getTimeBasedGreeting();
  
  // Adiciona contexto expl√≠cito sobre o nome do usu√°rio
  const userInfo = `[SISTEMA: O nome do usu√°rio √© ${profileName}]\n`;
  
  const formattedMessage = formatMessageWithDate(
    `${greeting} ${message.text ? message.text.body : ''}`,
    message.timestamp,
    profileName
  );

  const thread = await openaiService.createThread(
    `${userInfo}${formattedMessage}`, 
    phoneNumber
  );
  const threadId = thread.id;
  
  await redisService.setThreadId(phoneNumber, threadId);
  console.log(`Novo thread ID ${threadId} criado e armazenado para ${phoneNumber}`);
  
  return threadId;
}

async function saveMessageToRedis(message, phoneNumber, threadId, profileName) {
  const messageData = {
    id: message.id ? message.id.toString() : '',
    timestamp: message.timestamp ? message.timestamp.toString() : '',
    phoneNumber: phoneNumber ? phoneNumber.toString() : '',
    content: message.text && message.text.body ? message.text.body : '',
    assistantId: config.openai.assistantId || '',
    aiPhoneNumber: config.whatsapp.aiPhoneNumber || '',
    threadId: threadId ? threadId.toString() : '',
    createdAt: Date.now().toString(),
    localTime: moment().tz("America/Sao_Paulo").format('HH:mm:ss'),
    location: message.location ? { lat: message.location.latitude, long: message.location.longitude } : null,
    type: message.type ? message.type : 'text',
    status: message.status ? message.status : 'unknown',
    isAutoGenerated: false,
    deviceInfo: message.device ? message.device : 'unknown',
    userName: profileName
  };

  await redisService.saveMessage(message.id, messageData);
  console.log(`Message ID ${message.id} added to Redis with threadId ${threadId}`);
}

async function handleTextMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId) {
  const userMessage = message.text.body.toLowerCase();

  // Comando especial para apagar thread
  if (userMessage.includes("apagar thread_id")) {
    await handleDeleteThreadCommand(phoneNumber, phoneNumberId, message.from, res);
    return;
  }

  // Buffer de mensagens
  if (!messageBuffers.has(phoneNumber)) {
    messageBuffers.set(phoneNumber, []);
  }

  messageBuffers.get(phoneNumber).push(message.text.body);

  if (bufferTimeouts.has(phoneNumber)) {
    clearTimeout(bufferTimeouts.get(phoneNumber));
  }

  // Processar mensagens ap√≥s 4 segundos
  bufferTimeouts.set(phoneNumber, setTimeout(async () => {
    try {
      const bufferedMessages = messageBuffers.get(phoneNumber).join(' ');
      messageBuffers.delete(phoneNumber);
      bufferTimeouts.delete(phoneNumber);

      const currentDate = getCurrentDate();
      
      // Adiciona contexto do nome do usu√°rio na mensagem
      const messageWithContext = `[Usu√°rio ${profileName} diz:] ${bufferedMessages} [Data: ${currentDate}]`;
      
      const formattedMessage = formatMessageWithDate(
        messageWithContext,
        message.timestamp,
        profileName
      );

      // Armazenar mensagem do usu√°rio
      await redisService.storeMessageInConversation(phoneNumber, threadId, {
        role: 'user',
        content: formattedMessage,
        timestamp: Date.now()
      });

      // Verificar e gerenciar tokens
      let totalTokens = 0;
      try {
        totalTokens = await openaiService.getTokenUsage(threadId);
      } catch (tokenErr) {
        console.warn('Falha ao obter uso de tokens (continuando):', tokenErr?.message || tokenErr);
      }
      
      if (totalTokens > 1000000) {
        threadId = await handleTokenLimit(phoneNumber, threadId, formattedMessage);
      } else {
        await openaiService.addMessageWithRetry(threadId, formattedMessage);
      }

      // Processar com OpenAI
      const whatsappData = {
        phoneNumberId: phoneNumberId,
        recipientNumber: message.from
      };

      const assistantResponse = await openaiService.runAssistant(threadId, whatsappData);

      // Armazenar resposta do assistente
      await redisService.storeMessageInConversation(phoneNumber, threadId, {
        role: 'assistant',
        content: assistantResponse,
        timestamp: Date.now()
      });

      // Enviar resposta
      await whatsappService.sendReplyWithTimeout(
        phoneNumberId,
        config.whatsapp.graphApiToken,
        message.from,
        assistantResponse,
        res
      );
    } catch (error) {
      console.error('Erro ao processar mensagens em buffer:', error);
      try {
        await whatsappService.sendSplitReply(
          phoneNumberId,
          config.whatsapp.graphApiToken,
          message.from,
          'Tive um problema tempor√°rio ao responder. Pode repetir sua √∫ltima mensagem?',
          res
        );
      } catch (fallbackErr) {
        console.error('Erro ao enviar mensagem de fallback:', fallbackErr);
        if (!res.headersSent) {
          res.sendStatus(200);
        }
      }
    }
  }, 4000));
}

async function handleAudioMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId) {
  const mediaId = message.audio.id;
  
  if (!mediaId) {
    console.error("Media ID is undefined");
    return;
  }

  const audioUrl = await mediaService.fetchMediaUrl(mediaId);
  const audioContent = await mediaService.downloadAudio(audioUrl);
  const { transcription, language } = await audioService.transcribeAudio(audioContent);

  if (!transcription) {
    await whatsappService.sendSplitReply(
      phoneNumberId,
      config.whatsapp.graphApiToken,
      message.from,
      "Desculpe, por enquanto n√£o consigo ouvir seu √°udio, poderia escrever?",
      res
    );
    return;
  }

  // Verificar se deve responder com texto ou √°udio
  const shouldRespondWithText = transcription.toLowerCase().includes('link') || 
                                transcription.toLowerCase().includes('site');

  // Processar transcri√ß√£o
  const transcriptionWithContext = `[Usu√°rio ${profileName} enviou √°udio dizendo:] ${transcription}`;
  await openaiService.addMessageToThread(threadId, transcriptionWithContext);
  await redisService.storeMessageInConversation(phoneNumber, threadId, {
    role: 'user',
    content: transcriptionWithContext,
    timestamp: Date.now()
  });

  const whatsappData = {
    phoneNumberId: phoneNumberId,
    recipientNumber: message.from
  };

  const assistantResponse = await openaiService.runAssistant(threadId, whatsappData);

  await redisService.storeMessageInConversation(phoneNumber, threadId, {
    role: 'assistant',
    content: assistantResponse,
    timestamp: Date.now()
  });

  // Enviar resposta
  if (shouldRespondWithText) {
    await whatsappService.sendSplitReply(
      phoneNumberId,
      config.whatsapp.graphApiToken,
      message.from,
      assistantResponse,
      res
    );
  } else {
    await whatsappService.sendReply(
      phoneNumberId,
      config.whatsapp.graphApiToken,
      message.from,
      assistantResponse,
      res,
      true
    );
  }
}

async function handleImageMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId) {
  const mediaId = message.image.id;
  const caption = message.image.caption || "";

  if (!mediaId) {
    console.error("Media ID is undefined");
    return;
  }

  const imageUrl = await mediaService.fetchMediaUrl(mediaId);
  console.log("Image URL:", imageUrl);

  // Enviar mensagem de confirma√ß√£o
  await whatsappService.sendSplitReply(
    phoneNumberId,
    config.whatsapp.graphApiToken,
    message.from,
    "Recebi sua foto. Por favor, aguarde alguns instantes enquanto eu analiso! üïµüîç",
    res
  );

  const description = await mediaService.processImage(imageUrl, caption);

  if (description) {
    const instruction = `[Usu√°rio ${profileName} enviou uma imagem]\n\nEssa √© a descri√ß√£o da imagem foi enviada por uma outra IA para voc√™, Ultron. Use essa descri√ß√£o para gerar sua resposta. Lembre-se essa mensagem foi enviada por outra IA, n√£o pelo usu√°rio. Use essas informa√ß√µes para gerar uma resposta para ser enviada ao usu√°rio ${profileName}. Essa √© a descri√ß√£o da imagem e legenda que o usu√°rio incluiu (se houver): ${description}`;

    await redisService.storeMessageInConversation(phoneNumber, threadId, {
      role: 'user',
      content: instruction,
      timestamp: Date.now()
    });

    await openaiService.addMessageWithRetry(threadId, instruction);

    const whatsappData = {
      phoneNumberId: phoneNumberId,
      recipientNumber: message.from
    };

    const assistantResponse = await openaiService.runAssistant(threadId, whatsappData);

    await redisService.storeMessageInConversation(phoneNumber, threadId, {
      role: 'assistant',
      content: assistantResponse,
      timestamp: Date.now()
    });

    await whatsappService.sendReplyWithTimeout(
      phoneNumberId,
      config.whatsapp.graphApiToken,
      message.from,
      assistantResponse,
      res
    );
  }
}

async function handlePdfMessage(message, phoneNumber, profileName, phoneNumberId, res, threadId) {
  const mediaId = message.document.id;
  const mediaUrl = await mediaService.fetchMediaUrl(mediaId);

  // Enviar mensagem de confirma√ß√£o
  await whatsappService.sendSplitReply(
    phoneNumberId,
    config.whatsapp.graphApiToken,
    message.from,
    "Um momento, vou analisar o documento enviado.üïµüèª‚Äç‚ôÇÔ∏èüîç",
    res
  );

  const pdfContent = await mediaService.downloadPdf(mediaUrl);
  const extractedText = await mediaService.extractTextFromPdf(pdfContent);

  const instruction = `Este √© o texto do arquivo enviado. Responda de forma did√°tica.`;
  const content = `${instruction}\n\nTexto extra√≠do do PDF:\n${extractedText}`;

  await openaiService.addMessageToThread(threadId, content);

  await redisService.storeMessageInConversation(phoneNumber, threadId, {
    role: 'user',
    content: content,
    timestamp: Date.now()
  });

  await whatsappService.sendSplitReply(
    phoneNumberId,
    config.whatsapp.graphApiToken,
    message.from,
    "Documento analisado, j√° podemos falar sobre ele.",
    res
  );
}

async function handleDeleteThreadCommand(phoneNumber, phoneNumberId, from, res) {
  const threadId = await redisService.getThreadId(phoneNumber);

  if (threadId) {
    try {
      await openaiService.deleteThread(threadId);
      console.log(`Thread ${threadId} deletado no OpenAI.`);
    } catch (error) {
      console.error(`Erro ao deletar thread no OpenAI:`, error);
    }

    await redisService.deleteThreadId(phoneNumber);
    
    await whatsappService.sendSplitReply(
      phoneNumberId,
      config.whatsapp.graphApiToken,
      from,
      "Thread ID apagado com sucesso.",
      res
    );
  } else {
    await whatsappService.sendReply(
      phoneNumberId,
      config.whatsapp.graphApiToken,
      from,
      "Nenhum thread ID encontrado para apagar.",
      res
    );
  }
}

async function handleTokenLimit(phoneNumber, threadId, formattedMessage) {
  console.log(`Total de tokens excedeu 1.000.000 para o thread ${threadId}. Resumindo contexto...`);
  
  const summarizedContext = await openaiService.summarizeContext(threadId);
  const newThread = await openaiService.createThreadWithSummary(phoneNumber, summarizedContext);
  const newThreadId = newThread.id;
  
  await redisService.setThreadId(phoneNumber, newThreadId);
  console.log(`Novo thread ID ${newThreadId} criado com contexto resumido para ${phoneNumber}`);
  
  await openaiService.addMessageToThread(newThreadId, formattedMessage);
  
  return newThreadId;
}